from datetime import datetime
from django.core.exceptions import ObjectDoesNotExist
from django.db.models.fields import NOT_PROVIDED
from django.utils.decorators import method_decorator
from django.http import QueryDict, HttpResponseForbidden
from django.contrib.auth.decorators import login_required, user_passes_test
from django.views.decorators.csrf import csrf_exempt
from django.contrib.sessions.backends.db import SessionStore
from django.http import QueryDict

from plum.console.models import FPUser, Site
from . import calculate_signature


class RESTfulModelFormMixin(object):
    """
    Allows a model form to validate properly with optional attributes missing.

    Django model forms expect all attributes for a given model to be present
    in a request. Since a typical request comes from an HTML form and the HTML
    for that form is typically generated by the form object (which sets all
    of the HTML form values to the defaults of the model), this is usually not
    an issue. However, with RESTful requests, we cannot assume that all
    attributes will be present in the request.

    This mixin provides a method that will allow the form to validate even if
    some (optional) attributes are not present in the original request. It
    does so by adding the default values (from the model) to the data from the
    request for each missing attribute. It must add these elements to the data
    object, as opposed to just passing it to the form's __init__ method as the
    'initial' parameter since 'initial' is only used to render the HTML form
    and not for the validation of the data.

    To use this mixin, create a form class that inherits from the ModelForm
    class and from this class as well. Then, in the __init__ method call
    self.set_defaults() to populate the form's initial dataset with the
    model's default values.

    UPDATE:
    Mixin has been updated to also populate form with values from an
    instance, if it has been provided.
    Note: this has not yet been tested, and likely does not work, on
    many-to-many relationships.
    """

    def set_defaults(self):
        for field in self.instance.__class__._meta.fields:
            if field.name not in self.data.keys() or self.data.get(field.name) == None:
                inst_val = None
                if self.instance.id:
                    try:
                        inst_val = getattr(self.instance, field.name)
                        #Get the ID if this is a model object and
                        #we're dealing with a foreign key
                        #relationship.
                        inst_val = getattr(inst_val, 'id')
                    except (AttributeError, ObjectDoesNotExist):
                        pass
                    self.data[field.name] = inst_val
                elif field.default != NOT_PROVIDED:
                    self.data[field.name] = field.default


class ResourceMixin(object):
    """
    The resource mixin provides several 'conveniences' for writing RESTful
    APIs.
    """

    @csrf_exempt
    def dispatch(self, request, *args, **kwargs):
        # TODO: Move to a wrapper method, decorator, something

        if request.method.lower() == 'put':
            request.method = 'POST'
            request._load_post_and_files()
            request.method = 'PUT'
            request.PUT = request.POST

        method_in_GET = request.GET.get('_method', '').lower()
        method_in_POST = request.POST.get('_method', '').lower()

        #Ok, now let's remove that method.
        if request.GET and method_in_GET:
            GET = request.GET.copy()
            request.method = GET.pop('_method')[0]
            request.GET = params = GET
        elif request.POST and method_in_POST:
            POST = request.POST.copy()
            request.method = POST.pop('_method')[0]
            request.POST = POST

        if (method_in_GET or method_in_POST) == 'put':
            #Manually switch POST data to PUT
            request.PUT = POST
            request.POST = QueryDict({})


        # Try to dispatch to the right method; if a method doesn't exist,
        # defer to the error handler. Also defer to the error handler if the
        # request method isn't on the approved list.
        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed
        self.request = request
        self.args = args
        self.kwargs = kwargs

        # Handle request authentication
        if getattr(handler, 'auth_required', False):
            if request.GET.get('sig', False):
                if not self._validate_signature(request, kwargs.get('domain', None)):
                    return HttpResponseForbidden()
            else:
                if not request.GET.get('session_id', False):
                    handler = login_required(handler)
                elif not self._validate_session(request, kwargs.get('domain', None)):
                    return HttpResponseForbidden()
        elif getattr(handler, 'login_required', False):
            if not request.GET.get('session_id', False):
                handler = login_required(handler)
            elif not self._validate_session(request, kwargs.get('domain', None)):
                return HttpResponseForbidden()
        elif getattr(handler, 'admin_required', False):
            if not request.GET.get('session_id', False):
                handler = user_passes_test(lambda u: u.is_superuser)(handler)
            elif not self._validate_session(request, require_admin=True):
                return HttpResponseForbidden()
        elif getattr(handler, 'signature_required', False):
            if not self._validate_signature(request, kwargs.get('domain', None)):
                return HttpResponseForbidden()

        return handler(request, *args, **kwargs)

    def _validate_session(self, request, domain=None, require_admin=False):
        session_key = request.GET.get('session_id', None)
        if session_key:
            session = SessionStore(session_key).load()
            if '_auth_user_id' in session:
                try:
                    user = FPUser.objects.get(id=session['_auth_user_id'])
                    if user.is_superuser:
                        return True
                    elif require_admin:
                        return False
                    elif domain:
                        account = Site.objects.get(domain=domain).account
                        return account == user.account
                except:
                    pass
        return False


    def _validate_signature(self, request, domain):
        """
        Validates the signature associated with the given request.
        """

        # Extract the request parameters according to the HTTP method
        data = request.GET.copy()
        if request.method.lower() == 'post':
            data.update(request.POST.copy())
        elif request.method.lower() == 'put':
            data.update(request.PUT.copy())

        # TODO: Figure out another [good] way to get the secret key.
        #       The problem is that this app must now know something
        #       about the model classes that we've created, so this
        #       framework is currently coupled to our bacon app which
        #       not a very good design.
        # Get the secret key for the given domain
        try:
            site = Site.objects.get(domain=domain)
            secret_key = site.account.secret_key
        except Site.DoesNotExist, e:
            return False
        except Site.MultipleObjectsReturned, e:
            return False
        except Exception, e:
            return False

        # Make sure the request contains a signature
        if data.get('sig', False):
            sig = data['sig']
            del data['sig']
        else:
            return False

        # Make sure the request contains a timestamp
        if data.get('t', False):
            timestamp = int(data.get('t', False))
            del data['t']
        else:
            return False

        # Make sure the signature has not expired
        delta = datetime.utcnow() - datetime.utcfromtimestamp(timestamp)
        if delta.seconds > 5*60: # If the signature is older than 5 minutes, it's invalid
            return False

        # Make sure the signature is valid
        return sig == calculate_signature(secret_key, data, timestamp)
